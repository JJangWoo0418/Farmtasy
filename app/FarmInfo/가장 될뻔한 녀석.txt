// app/Components/Css/FarmInfo/WeatherAPI.js
import axios from 'axios';
import { WEATHER_API_KEY_PORTAL, WEATHER_API_KEY_KMA } from '../../API/apikey';
import { XMLParser } from 'fast-xml-parser';

// XML íŒŒì„œ ì„¤ì •
const parser = new XMLParser();

// ê³µí†µ API ìš”ì²­ í•¨ìˆ˜
const fetchAPI = async (url, params, useKmaKey = false) => {
  try {
    const finalParams = {
      ...params,
      ...(url.includes('data.go.kr')
        ? { serviceKey: WEATHER_API_KEY_PORTAL }
        : { authKey: WEATHER_API_KEY_KMA }),
    };

    const response = await axios.get(url, { params: finalParams });
    const xml = response.data;
    console.log('[LOG] ë‚ ì”¨ API ì› ì‘ë‹µ:', xml);
    const json = parser.parse(xml);
    return json;
  } catch (error) {
    console.error('[ERROR] ê¸°ìƒì²­ API ìš”ì²­ ì˜¤ë¥˜:', error);
    return null;
  }
};

// í†µí•© í˜¸ì¶œ í•¨ìˆ˜
export const fetchWeather = async (type, params) => {
  switch (type) {
    case 'ultraNcst':
      return await fetchUltraSrtNcst(params);
    case 'ultraFcst':
      return await fetchUltraSrtFcst(params);
    case 'vilageFcst':
      return await fetchVilageFcst(params);
    case 'midLandFcst':
      return await fetchMidLandFcst(params);
    case 'midTa':
      return await fetchMidTa(params);
    case 'warning':
      return await fetchWarningNow();
    case 'typhoon':
      return await fetchTyphoon(params);
    case 'latlon': {
      const { lat, lon } = params || {};
      if (lat === undefined || lon === undefined) {
        console.error('[ERROR] ê²©ì ë³€í™˜ íŒŒë¼ë¯¸í„° ëˆ„ë½');
        return null;
      }
      return await convertLatLonToGrid({ lat, lon });
    }
    default:
      console.error('[ERROR] ì•Œ ìˆ˜ ì—†ëŠ” ìš”ì²­ ìœ í˜•:', type);
      return null;
  }
};

// ì´ˆë‹¨ê¸°ì‹¤í™©ì¡°íšŒ
export const fetchUltraSrtNcst = async ({ nx, ny, base_date, base_time }) => {
  return await fetchAPI('https://apis.data.go.kr/1360000/VilageFcstInfoService_2.0/getUltraSrtNcst', {
    pageNo: 1,
    numOfRows: 1000,
    dataType: 'XML',
    base_date,
    base_time,
    nx,
    ny,
  });
};

// ì´ˆë‹¨ê¸°ì˜ˆë³´ì¡°íšŒ
export const fetchUltraSrtFcst = async ({ nx, ny, base_date, base_time }) => {
  return await fetchAPI('https://apis.data.go.kr/1360000/VilageFcstInfoService_2.0/getUltraSrtFcst', {
    pageNo: 1,
    numOfRows: 1000,
    dataType: 'XML',
    base_date,
    base_time,
    nx,
    ny,
  });
};

// ë‹¨ê¸°ì˜ˆë³´ì¡°íšŒ
export const fetchVilageFcst = async ({ nx, ny, base_date, base_time }) => {
  return await fetchAPI('https://apis.data.go.kr/1360000/VilageFcstInfoService_2.0/getVilageFcst', {
    pageNo: 1,
    numOfRows: 1000,
    dataType: 'XML',
    base_date,
    base_time,
    nx,
    ny,
  });
};

// ì¤‘ê¸°ìœ¡ìƒì˜ˆë³´
export const fetchMidLandFcst = async ({ regId, tmFc }) => {
  return await fetchAPI('https://apis.data.go.kr/1360000/MidFcstInfoService/getMidLandFcst', {
    dataType: 'XML',
    regId,
    tmFc,
  });
};

// ì¤‘ê¸°ê¸°ì˜¨ì˜ˆë³´
export const fetchMidTa = async ({ regId, tmFc }) => {
  return await fetchAPI('https://apis.data.go.kr/1360000/MidFcstInfoService/getMidTa', {
    dataType: 'XML',
    regId,
    tmFc,
  });
};

// ê¸°ìƒíŠ¹ë³´
export const fetchWarningNow = async () => {
  return await fetchAPI('https://apihub.kma.go.kr/api/typ01/url/wrn_now_data.php', {
    fe: 'f',
  }, true);
};

// íƒœí’ì •ë³´
export const fetchTyphoon = async ({ YY, typ, seq, mode }) => {
  return await fetchAPI('https://apihub.kma.go.kr/api/typ01/url/typ_data.php', {
    YY,
    typ,
    seq,
    mode,
  }, true);
};

// ìœ„ê²½ë„ â†’ ê²©ìë³€í™˜
export const convertLatLonToGrid = async ({ lat, lon }) => {
  try {
    console.log('[LOG] ëª¨ë“œ: latlon');
    console.log('[LOG] ê²©ì ë³€í™˜ ìš”ì²­ ì¢Œí‘œ:', { lat, lon });

    const response = await axios.get('https://apihub.kma.go.kr/api/typ01/cgi-bin/url/nph-dfs_xy_lonlat', {
      params: {
        lat,
        lon,
        authKey: WEATHER_API_KEY_KMA,
      },
    });

    const text = response.data;
    const match = text.match(/\s+(\d+\.\d+),\s+(\d+\.\d+),\s+(\d+),\s+(\d+)/);

    if (match) {
      const result = {
        lon: parseFloat(match[1]),
        lat: parseFloat(match[2]),
        x: parseInt(match[3]),
        y: parseInt(match[4]),
      };
      console.log('[LOG] ê²©ì ì •ë³´:', result);
      return result;
    } else {
      console.error('[ERROR] ê²©ì ì •ë³´ ì—†ìŒ.');
      return null;
    }
  } catch (error) {
    console.error('[ERROR] ê²©ì ë³€í™˜ ìš”ì²­ ì˜¤ë¥˜:', error);
    return null;
  }
};

ê°€ì¥ ë ë»”í•œ ì½”ë“œ Weather.js

// app/FarmInfo/index.js
import React, { useEffect, useState } from 'react';
import { View, Text, Button, ScrollView } from 'react-native';
import styles from '../Components/Css/FarmInfo/index.js';
import { fetchWeather } from '../Components/Css/FarmInfo/WeatherAPI';
import { getBaseDateTime } from '../Components/Utils/timeUtils';
import * as Location from 'expo-location'; // Expo Location API ì‚¬ìš©

const FARM_COORDS = {
  latitude: 36.953862288,
  longitude: 127.681782599,
  //ìš°ë¦¬ì§‘ ìŒì„±
};

export default function FarmInfo() {
  const [mode, setMode] = useState('farm');
  const [weatherData, setWeatherData] = useState(null);
  const [weeklyData, setWeeklyData] = useState(null);
  const [warningData, setWarningData] = useState('');
  const [loading, setLoading] = useState(false);

  const loadWeather = async () => {
    setLoading(true);
    let coords = FARM_COORDS;
    console.log('[ê³µí†µ] í˜„ì¬ ì„¤ì •ëœ ë†ì¥ ì¢Œí‘œ:', coords);

    if (mode === 'current') {
      try {
        const { status } = await Location.requestForegroundPermissionsAsync();
        if (status !== 'granted') {
          console.error('[ê³µí†µ] ìœ„ì¹˜ ê¶Œí•œ ê±°ë¶€ë¨');
          setLoading(false);
          return;
        }

        const position = await Location.getCurrentPositionAsync({});
        coords = {
          latitude: position.coords.latitude,
          longitude: position.coords.longitude,
        };
        console.log('[ê³µí†µ] í˜„ì¬ ìœ„ì¹˜ ì¢Œí‘œ:', coords);
      } catch (error) {
        console.error('[ê³µí†µ] í˜„ì¬ ìœ„ì¹˜ ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨:', error);
        setLoading(false);
        return;
      }
    }

    const { base_date, base_time } = getBaseDateTime();
    console.log('[ê³µí†µ] ê¸°ì¤€ ë‚ ì§œ ë° ì‹œê°„:', base_date, base_time);

    const grid = await fetchWeather('latlon', {
      lat: coords.latitude,
      lon: coords.longitude,
    });
    console.log('[ê²©ìë³€í™˜] ê²°ê³¼:', grid);
    if (!grid || !grid.x || !grid.y) {
      setLoading(false);
      return;
    }

    console.log('[ì‹œê°„ëŒ€ë³„ ë‚ ì”¨] ìš”ì²­ ì¢Œí‘œ:', grid.x, grid.y);
    const forecast = await fetchWeather('ultraFcst', {
      nx: grid.x,
      ny: grid.y,
      base_date,
      base_time,
    });
    console.log('[ì‹œê°„ëŒ€ë³„ ë‚ ì”¨] ì‘ë‹µ:', forecast);

    const midForecast = grid.midLandId && grid.tmFc ? await fetchWeather('midLandFcst', {
      regId: grid.midLandId,
      tmFc: grid.tmFc,
    }) : null;
    console.log('[ì£¼ê°„ ë‚ ì”¨] ì‘ë‹µ:', midForecast);

    const warning = await fetchWeather('warning');
    console.log('[ê¸°ìƒ íŠ¹ë³´] ì‘ë‹µ:', warning);

    if (forecast) setWeatherData(forecast);
    if (midForecast) setWeeklyData(midForecast);
    if (typeof warning === 'string') setWarningData(warning);

    setLoading(false);
  };

  useEffect(() => {
    loadWeather();
  }, [mode]);

  const getEmojiForPty = (value) => {
    switch (value) {
      case '0': return 'â˜€ ';
      case '1': return 'ğŸŒ§ ';
      case '2': return 'ğŸŒ¦ ';
      case '3': return 'â„ ';
      case '4': return 'ğŸŒ¨ ';
      default: return 'â˜ ';
    }
  };

  const getEmojiForSky = (value) => {
    switch (value) {
      case '1': return 'â˜€ ';
      case '3': return 'â›… ';
      case '4': return 'â˜ ';
      default: return 'â˜ ';
    }
  };

  const renderForecast = () => {
    const msg = weatherData?.response?.header?.resultMsg;
    const code = weatherData?.response?.header?.resultCode;
    if (msg !== 'NORMAL_SERVICE') return <Text style={styles.errorText}>ì—ëŸ¬: {msg} (ì½”ë“œ {code})</Text>;

    const items = weatherData?.response?.body?.items?.item || [];
    const categories = ['PTY', 'RN1', 'SKY', 'T1H', 'REH'];
    const grouped = {};

    for (const item of items) {
      if (!categories.includes(item.category)) continue;
      if (!grouped[item.fcstTime]) grouped[item.fcstTime] = {};
      grouped[item.fcstTime][item.category] = item.fcstValue;
    }

    console.log('[ì‹œê°„ëŒ€ë³„ ë‚ ì”¨] ê·¸ë£¹í™”ëœ ë°ì´í„°:', grouped);

    return Object.entries(grouped).map(([time, data], idx) => {
      const pty = data['PTY'];
      const rn1 = data['RN1'];
      const sky = data['SKY'];
      const t1h = data['T1H'];
      const reh = data['REH'];
      const emoji = pty !== '0' ? getEmojiForPty(pty) : getEmojiForSky(sky);
      const rainInfo = (pty !== '0' && rn1 !== 'ê°•ìˆ˜ì—†ìŒ') ? `${rn1} ` : '';
      const temp = t1h ? `${t1h} â„ƒ ` : '';
      const humidity = reh ? `${reh}%` : '';
      const hour = `${String(time).padStart(4, '0').slice(0, 2)}ì‹œ`;

      return (
        <View key={idx} style={styles.row}>
          <Text style={styles.time}>{hour}</Text>
          <Text style={styles.value}>{emoji}</Text>
          <Text style={styles.value}>{rainInfo}</Text>
          <Text style={styles.value}>{temp}</Text>
          <Text style={styles.value}>{humidity}</Text>
        </View>
      );
    });
  };

  const renderWeekly = () => {
    const items = weeklyData?.response?.body?.items?.item || [];
    const filtered = items.filter(item => item.wfAm && item.wfPm);
    console.log('[ì£¼ê°„ ë‚ ì”¨] í•„í„°ë§ëœ ë°ì´í„°:', filtered);
    if (filtered.length === 0) return <Text style={styles.noWarning}>ì£¼ê°„ ì˜ˆë³´ ë°ì´í„° ì—†ìŒ</Text>;

    const getEmoji = (text) => {
      if (text.includes('ë§‘')) return 'â˜€';
      if (text.includes('êµ¬ë¦„ë§')) return 'â›…';
      if (text.includes('íë¦¼')) return 'â˜';
      if (text.includes('ë¹„')) return 'ğŸŒ§';
      if (text.includes('ëˆˆ')) return 'â„';
      return 'â“';
    };

    return filtered.map((item, idx) => (
      <View key={idx} style={styles.row}>
        <Text style={styles.time}>{item.fcstDate}</Text>
        <Text style={styles.value}>{getEmoji(item.wfAm)} / {getEmoji(item.wfPm)}</Text>
        <Text style={styles.value}>{item.wfAm} / {item.wfPm}</Text>
      </View>
    ));
  };

  const renderWarning = () => {
    const lines = typeof warningData === 'string'
      ? warningData.split('\n').filter(line => line.startsWith('L'))
      : [];
    console.log('[ê¸°ìƒ íŠ¹ë³´] íŒŒì‹±ëœ íŠ¹ë³´ ë¼ì¸:', lines);
    if (lines.length === 0) return <Text style={styles.noWarning}>í˜„ì¬ ë°œíš¨ ì¤‘ì¸ íŠ¹ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.</Text>;
    return lines.map((line, idx) => <Text key={idx} style={styles.warningLine}>{line}</Text>);
  };

  return (
    <ScrollView style={styles.container}>
      <View style={styles.tabContainer}>
        <Button title="ë‚´ ë†ì¥ ë‚ ì”¨" onPress={() => setMode('farm')} />
        <Button title="í˜„ ìœ„ì¹˜ ë‚ ì”¨" onPress={() => setMode('current')} />
      </View>

      <View style={styles.weatherBox}>
        <Text style={styles.sectionTitle}>[ì‹œê°„ëŒ€ë³„ ë‚ ì”¨]</Text>
        {loading ? (
          <Text style={styles.loading}>ë¡œë”©ì¤‘...</Text>
        ) : (
          renderForecast()
        )}
      </View>

      <View style={styles.weatherBox}>
        <Text style={styles.sectionTitle}>[ì£¼ê°„ ë‚ ì”¨]</Text>
        {loading ? (
          <Text style={styles.loading}>ë¡œë”©ì¤‘...</Text>
        ) : (
          renderWeekly()
        )}
      </View>

      <View style={styles.weatherBox}>
        <Text style={styles.sectionTitle}>[ê¸°ìƒ íŠ¹ë³´]</Text>
        {loading ? (
          <Text style={styles.loading}>ë¡œë”©ì¤‘...</Text>
        ) : (
          renderWarning()
        )}
      </View>
    </ScrollView>
  );
}

4ì›” 13ì¼
-ì„¸ì´ë¸Œ ë³¸- 
// app/FarmInfo/index.js
import React, { useEffect, useState } from 'react';
import { View, Text, Button, ScrollView } from 'react-native';
import styles from '../Components/Css/FarmInfo/index.js';
import { fetchWeather } from '../Components/Css/FarmInfo/WeatherAPI';
import { getBaseDateTime } from '../Components/Utils/timeUtils';
import { getMidLandRegId } from '../Components/Utils/regionMapper';
import * as Location from 'expo-location';

const FARM_COORDS = {
  latitude: 36.953862288,
  longitude: 127.681782599,
};

export default function FarmInfo() {
  const [mode, setMode] = useState('farm');
  const [weatherData, setWeatherData] = useState(null);
  const [weeklyData, setWeeklyData] = useState(null);
  const [warningData, setWarningData] = useState('');
  const [loading, setLoading] = useState(false);

  const loadWeather = async () => {
    setLoading(true);
    let coords = FARM_COORDS;
    console.log('[ê³µí†µ] í˜„ì¬ ì„¤ì •ëœ ë†ì¥ ì¢Œí‘œ:', coords);

    if (mode === 'current') {
      try {
        const { status } = await Location.requestForegroundPermissionsAsync();
        if (status !== 'granted') {
          console.error('[ê³µí†µ] ìœ„ì¹˜ ê¶Œí•œ ê±°ë¶€ë¨');
          setLoading(false);
          return;
        }

        const position = await Location.getCurrentPositionAsync({});
        coords = {
          latitude: position.coords.latitude,
          longitude: position.coords.longitude,
        };
        console.log('[ê³µí†µ] í˜„ì¬ ìœ„ì¹˜ ì¢Œí‘œ:', coords);
      } catch (error) {
        console.error('[ê³µí†µ] í˜„ì¬ ìœ„ì¹˜ ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨:', error);
        setLoading(false);
        return;
      }
    }

    const now = new Date();
    const currentHour = now.getHours();
    const baseDate = new Date(now);

    if (currentHour < 6) {
      baseDate.setDate(baseDate.getDate() - 1);
    }

    const yyyy = baseDate.getFullYear();
    const mm = String(baseDate.getMonth() + 1).padStart(2, '0');
    const dd = String(baseDate.getDate()).padStart(2, '0');
    const dateStr = `${yyyy}${mm}${dd}`;
    const tmFc = currentHour < 6 || currentHour >= 18 ? `${dateStr}1800` : `${dateStr}0600`;

    const { base_date, base_time } = getBaseDateTime();
    console.log('[ê³µí†µ] ê¸°ì¤€ ë‚ ì§œ ë° ì‹œê°„:', base_date, base_time);

    const grid = await fetchWeather('latlon', {
      lat: coords.latitude,
      lon: coords.longitude,
    });
    console.log('[ê²©ìë³€í™˜] ê²°ê³¼:', grid);
    if (!grid || !grid.x || !grid.y) {
      setLoading(false);
      return;
    }

    console.log('[ì‹œê°„ëŒ€ë³„ ë‚ ì”¨] ìš”ì²­ ì¢Œí‘œ:', grid.x, grid.y);
    const forecast = await fetchWeather('ultraFcst', {
      nx: grid.x,
      ny: grid.y,
      base_date,
      base_time,
    });
    console.log('[ì‹œê°„ëŒ€ë³„ ë‚ ì”¨] ì‘ë‹µ:', forecast);

    const regId = getMidLandRegId(coords.latitude, coords.longitude);
    const midForecast = await fetchWeather('midLandFcst', { regId, tmFc });
    console.log('[ì£¼ê°„ ë‚ ì”¨] ìš”ì²­ íŒŒë¼ë¯¸í„°:', { regId, tmFc });
    console.log('[ì£¼ê°„ ë‚ ì”¨] ì‘ë‹µ:', midForecast);

    const warning = await fetchWeather('warning');
    console.log('[ê¸°ìƒ íŠ¹ë³´] ì‘ë‹µ:', warning);

    if (forecast) setWeatherData(forecast);
    if (
      midForecast?.response?.header?.resultCode === '00' &&
      Array.isArray(midForecast?.response?.body?.items?.item)
    ) {
      const items = midForecast.response.body.items.item;
      const validItems = items.filter(item => item.wfAm || item.wfPm);
      setWeeklyData({ response: { body: { items: { item: validItems } } } });
    } else {
      console.warn('[ì£¼ê°„ ë‚ ì”¨] ìœ íš¨í•˜ì§€ ì•Šì€ ì‘ë‹µ ë˜ëŠ” ë°ì´í„° ì—†ìŒ:', midForecast);
    }
    if (typeof warning === 'string') setWarningData(warning);

    setLoading(false);
  };

  useEffect(() => {
    loadWeather();
  }, [mode]);

  const getEmojiForPty = (value) => {
    switch (value) {
      case '0': return 'â˜€ ';
      case '1': return 'ğŸŒ§ ';
      case '2': return 'ğŸŒ¦ ';
      case '3': return 'â„ ';
      case '4': return 'ğŸŒ¨ ';
      default: return 'â˜ ';
    }
  };

  const getEmojiForSky = (value) => {
    switch (value) {
      case '1': return 'â˜€ ';
      case '3': return 'â›… ';
      case '4': return 'â˜ ';
      default: return 'â˜ ';
    }
  };

  const renderForecast = () => {
    const msg = weatherData?.response?.header?.resultMsg;
    const code = weatherData?.response?.header?.resultCode;
    if (msg !== 'NORMAL_SERVICE') return <Text style={styles.errorText}>ì—ëŸ¬: {msg} (ì½”ë“œ {code})</Text>;

    const items = weatherData?.response?.body?.items?.item || [];
    const categories = ['PTY', 'RN1', 'SKY', 'T1H', 'REH'];
    const grouped = {};

    for (const item of items) {
      if (!categories.includes(item.category)) continue;
      if (!grouped[item.fcstTime]) grouped[item.fcstTime] = {};
      grouped[item.fcstTime][item.category] = item.fcstValue;
    }

    console.log('[ì‹œê°„ëŒ€ë³„ ë‚ ì”¨] ê·¸ë£¹í™”ëœ ë°ì´í„°:', grouped);

    const now = new Date();
    const currentHour = now.getHours();
    const sortedTimes = Object.keys(grouped).sort((a, b) => {
      const aHour = parseInt(a);
      const bHour = parseInt(b);
      const offsetA = (aHour + 24 - currentHour) % 24;
      const offsetB = (bHour + 24 - currentHour) % 24;
      return offsetA - offsetB;
    });

    return (
      <ScrollView style={{ maxHeight: 600 }} nestedScrollEnabled={true}>
        {sortedTimes.map((time, idx) => {
          const data = grouped[time] || {};
          const pty = data['PTY'];
          const rn1 = data['RN1'];
          const sky = data['SKY'];
          const t1h = data.hasOwnProperty('T1H') ? ` ${data['T1H']} â„ƒ ` : ' - ';
          const reh = data.hasOwnProperty('REH') ? `${data['REH']}% ` : ' - ';
          const emoji = pty !== '0' ? getEmojiForPty(pty) : getEmojiForSky(sky);
          const rainInfo = rn1 ? (pty !== '0 ' && rn1 !== 'ê°•ìˆ˜ì—†ìŒ ' ? `${rn1}` : 'ê°•ìˆ˜ì—†ìŒ ') : 'ê°•ìˆ˜ì—†ìŒ ';
          const hour = `${String(time).padStart(4, '0').slice(0, 2)} ì‹œ`;

          return (
            <View key={idx} style={styles.row}>
              <Text style={styles.time}>{hour}</Text>
              <Text style={styles.value}>{emoji}</Text>
              <Text style={styles.value}>{rainInfo}</Text>
              <Text style={styles.value}>{t1h}</Text>
              <Text style={styles.value}>{reh}</Text>
            </View>
          );
        })}
      </ScrollView>
    );
  };

  const renderWeekly = () => {
    const items = weeklyData?.response?.body?.items?.item || [];
    console.log('[ì£¼ê°„ ë‚ ì”¨] ì›ì‹œ ë°ì´í„°:', items);
    if (items.length === 0) return <Text style={styles.noWarning}>ì£¼ê°„ ì˜ˆë³´ ë°ì´í„° ì—†ìŒ</Text>;

    const getEmoji = (text) => {
      if (text.includes('ë§‘')) return 'â˜€ ';
      if (text.includes('êµ¬ë¦„ë§')) return 'â›… ';
      if (text.includes('íë¦¼')) return 'â˜ ';
      if (text.includes('ë¹„')) return 'ğŸŒ§ ';
      if (text.includes('ëˆˆ')) return 'â„ ';
      return 'â“';
    };

    return items.map((item, idx) => (
      <View key={idx} style={styles.row}>
        <Text style={styles.time}>{item.fcstDate}</Text>
        <Text style={styles.value}>{getEmoji(item.wfAm)} / {getEmoji(item.wfPm)}</Text>
        <Text style={styles.value}>{item.wfAm} / {item.wfPm}</Text>
      </View>
    ));
  };

  const renderWarning = () => {
    const lines = typeof warningData === 'string'
      ? warningData.split('\n').filter(line => line.startsWith('L'))
      : [];
    console.log('[ê¸°ìƒ íŠ¹ë³´] íŒŒì‹±ëœ íŠ¹ë³´ ë¼ì¸:', lines);
    if (lines.length === 0) return <Text style={styles.noWarning}>í˜„ì¬ ë°œíš¨ ì¤‘ì¸ íŠ¹ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.</Text>;
    return lines.map((line, idx) => <Text key={idx} style={styles.warningLine}>{line}</Text>);
  };

  return (
    <ScrollView style={styles.container} nestedScrollEnabled={true}>
      <View style={styles.tabContainer}>
        <Button title="ë‚´ ë†ì¥ ë‚ ì”¨" onPress={() => setMode('farm')} />
        <Button title="í˜„ ìœ„ì¹˜ ë‚ ì”¨" onPress={() => setMode('current')} />
      </View>

      <View style={styles.weatherBox}>
        <Text style={styles.sectionTitle}>[ì‹œê°„ëŒ€ë³„ ë‚ ì”¨]</Text>
        {loading ? (
          <Text style={styles.loading}>ë¡œë”©ì¤‘...</Text>
        ) : (
          renderForecast()
        )}
      </View>

      <View style={styles.weatherBox}>
        <Text style={styles.sectionTitle}>[ì£¼ê°„ ë‚ ì”¨]</Text>
        {loading ? (
          <Text style={styles.loading}>ë¡œë”©ì¤‘...</Text>
        ) : (
          renderWeekly()
        )}
      </View>

      <View style={styles.weatherBox}>
        <Text style={styles.sectionTitle}>[ê¸°ìƒ íŠ¹ë³´]</Text>
        {loading ? (
          <Text style={styles.loading}>ë¡œë”©ì¤‘...</Text>
        ) : (
          renderWarning()
        )}
      </View>
    </ScrollView>
  );
}


-------- timeUtils.js ì„¸ì´ë¸Œë³¸ ---------
// app/Components/Utils/timeUtils.js
export const getBaseDateTime = () => {
    const now = new Date();
  
    // ê¸°ìƒì²­ APIëŠ” ë§¤ ì •ì‹œ ê¸°ì¤€, 40ë¶„ í›„ë¶€í„° ë°ì´í„°ë¥¼ ì œê³µí•¨
    // ì˜ˆ: 12:40 ì´í›„ â†’ base_timeì€ 12:00
    let baseDate = now;
    let baseTime = new Date(now.getTime() - 60 * 60 * 1000); // 1ì‹œê°„ ì „
  
    const y = baseDate.getFullYear();
    const m = String(baseDate.getMonth() + 1).padStart(2, '0');
    const d = String(baseDate.getDate()).padStart(2, '0');
    const h = String(baseTime.getHours()).padStart(2, '0');
    const min = baseTime.getMinutes();
  
    const base_date = `${y}${m}${d}`;
    const base_time = `${h}00`;
  
    return { base_date, base_time };
  };
  





  ----------------------------------

  4ì›” 14ì¼ 01ì‹œ01ë¶„ ê¸°ì¤€ ë˜ëŠ” ì½”ë“œ

  WeatherAPI.js
// app/Components/Css/FarmInfo/WeatherAPI.js

import axios from 'axios';
import { WEATHER_API_KEY_PORTAL, WEATHER_API_KEY_KMA } from '../../API/apikey';
import { XMLParser } from 'fast-xml-parser';

// fast-xml-parser ì„¤ì •
const parser = new XMLParser({
  ignoreAttributes: false,
  attributeNamePrefix: '',
  isArray: (name) => name === 'item',
});

// ê³µí†µ API ìš”ì²­ í•¨ìˆ˜
const fetchAPI = async (url, params) => {
  try {
    const response = await axios.get(url, { params });
    const xml = response.data;
    console.log('[LOG] ë‚ ì”¨ API ì› ì‘ë‹µ:', xml);
    return parser.parse(xml);
  } catch (error) {
    console.error('[ERROR] ê¸°ìƒì²­ API ìš”ì²­ ì˜¤ë¥˜:', error);
    return null;
  }
};

// fallback ë‚ ì§œ êµ¬í•˜ê¸° í•¨ìˆ˜ (ì–´ì œ ë‚ ì§œ)
const getFallbackDate = (baseDate) => {
  const date = new Date(baseDate.slice(0, 4), baseDate.slice(4, 6) - 1, baseDate.slice(6, 8));
  date.setDate(date.getDate() - 1);
  const yyyy = date.getFullYear();
  const mm = String(date.getMonth() + 1).padStart(2, '0');
  const dd = String(date.getDate()).padStart(2, '0');
  return `${yyyy}${mm}${dd}`;
};

// í†µí•© í˜¸ì¶œ í•¨ìˆ˜
export const fetchWeather = async (type, params) => {
  switch (type) {
    case 'ultraNcst':
      return await fetchUltraSrtNcst(params);
    case 'ultraFcst':
      return await fetchUltraSrtFcst(params);
    case 'vilageFcst':
      return await fetchVilageFcst(params);
    case 'midLandFcst':
      return await fetchMidLandFcst(params);
    case 'midTa':
      return await fetchMidTa(params);
    case 'warning':
      return await fetchWarningNow();
    case 'typhoon':
      return await fetchTyphoon(params);
    case 'latlon':
      return await convertLatLonToGrid(params);
    default:
      console.error('[ERROR] ì•Œ ìˆ˜ ì—†ëŠ” ìš”ì²­ ìœ í˜•:', type);
      return null;
  }
};

// ì´ˆë‹¨ê¸°ì‹¤í™©ì¡°íšŒ
export const fetchUltraSrtNcst = async ({ nx, ny, base_date, base_time }) => {
  return await fetchAPI('https://apis.data.go.kr/1360000/VilageFcstInfoService_2.0/getUltraSrtNcst', {
    serviceKey: WEATHER_API_KEY_PORTAL,
    pageNo: 1,
    numOfRows: 1000,
    dataType: 'XML',
    base_date,
    base_time,
    nx,
    ny,
  });
};

// ì´ˆë‹¨ê¸°ì˜ˆë³´ì¡°íšŒ (fallback ì ìš©)
export const fetchUltraSrtFcst = async (params) => {
  const res = await fetchAPI('https://apis.data.go.kr/1360000/VilageFcstInfoService_2.0/getUltraSrtFcst', {
    serviceKey: WEATHER_API_KEY_PORTAL,
    pageNo: 1,
    numOfRows: 1000,
    dataType: 'XML',
    ...params,
  });

  const code = res?.response?.header?.resultCode;
  if (code === '03' || !res?.response?.body?.items?.item?.length) {
    console.warn('[WARN] ì´ˆë‹¨ê¸°ì˜ˆë³´ NO_DATA fallback ì ìš©');
    const fallbackDate = getFallbackDate(params.base_date);
    return await fetchAPI('https://apis.data.go.kr/1360000/VilageFcstInfoService_2.0/getUltraSrtFcst', {
      ...params,
      base_date: fallbackDate,
      serviceKey: WEATHER_API_KEY_PORTAL,
      pageNo: 1,
      numOfRows: 1000,
      dataType: 'XML',
    });
  }

  return res;
};

// ë‹¨ê¸°ì˜ˆë³´ì¡°íšŒ
export const fetchVilageFcst = async ({ nx, ny, base_date, base_time }) => {
  return await fetchAPI('https://apis.data.go.kr/1360000/VilageFcstInfoService_2.0/getVilageFcst', {
    serviceKey: WEATHER_API_KEY_PORTAL,
    pageNo: 1,
    numOfRows: 1000,
    dataType: 'XML',
    base_date,
    base_time,
    nx,
    ny,
  });
};

// ì¤‘ê¸°ìœ¡ìƒì˜ˆë³´ (fallback ì ìš©)
export const fetchMidLandFcst = async ({ regId, tmFc }) => {
  const res = await fetchAPI('https://apis.data.go.kr/1360000/MidFcstInfoService/getMidLandFcst', {
    serviceKey: WEATHER_API_KEY_PORTAL,
    dataType: 'XML',
    regId,
    tmFc,
  });

  const code = res?.response?.header?.resultCode;
  if (code === '03' || !res?.response?.body?.items?.item?.length) {
    console.warn('[WARN] ì¤‘ê¸°ìœ¡ìƒì˜ˆë³´ NO_DATA fallback ì ìš©');
    const fallbackDate = getFallbackDate(tmFc.slice(0, 8)) + tmFc.slice(8);
    return await fetchAPI('https://apis.data.go.kr/1360000/MidFcstInfoService/getMidLandFcst', {
      serviceKey: WEATHER_API_KEY_PORTAL,
      dataType: 'XML',
      regId,
      tmFc: fallbackDate,
    });
  }

  return res;
};

// ì¤‘ê¸°ê¸°ì˜¨ì˜ˆë³´ (fallback ì ìš©)
export const fetchMidTa = async ({ regId, tmFc }) => {
  const res = await fetchAPI('https://apis.data.go.kr/1360000/MidFcstInfoService/getMidTa', {
    serviceKey: WEATHER_API_KEY_PORTAL,
    dataType: 'XML',
    regId,
    tmFc,
  });

  const code = res?.response?.header?.resultCode;
  if (code === '03' || !res?.response?.body?.items?.item?.length) {
    console.warn('[WARN] ì¤‘ê¸°ê¸°ì˜¨ì˜ˆë³´ NO_DATA fallback ì ìš©');
    const fallbackDate = getFallbackDate(tmFc.slice(0, 8)) + tmFc.slice(8);
    return await fetchAPI('https://apis.data.go.kr/1360000/MidFcstInfoService/getMidTa', {
      serviceKey: WEATHER_API_KEY_PORTAL,
      dataType: 'XML',
      regId,
      tmFc: fallbackDate,
    });
  }

  return res;
};

// ê¸°ìƒíŠ¹ë³´ ì¡°íšŒ (fallback ì ìš©)
export const fetchWarningNow = async () => {
  const res = await fetchAPI('https://apis.data.go.kr/1360000/WthrWrnInfoService/getWthrWrnList', {
    serviceKey: WEATHER_API_KEY_PORTAL,
    dataType: 'XML',
    pageNo: 1,
    numOfRows: 100,
  });

  const code = res?.response?.header?.resultCode;
  if (code === '03' || !res?.response?.body?.items?.item?.length) {
    console.warn('[WARN] ê¸°ìƒíŠ¹ë³´ NO_DATA fallback ì ìš© - ì´ì „ ë‚  ê¸°ì¤€ ìš”ì²­ ì—†ìŒ');
    return null;
  }

  return res;
};

// íƒœí’ì •ë³´
export const fetchTyphoon = async ({ YY, typ, seq, mode }) => {
  return await fetchAPI('https://apihub.kma.go.kr/api/typ01/url/typ_data.php', {
    authKey: WEATHER_API_KEY_KMA,
    YY,
    typ,
    seq,
    mode,
  });
};

// ìœ„ê²½ë„ â†’ ê²©ìë³€í™˜
export const convertLatLonToGrid = async ({ lat, lon }) => {
  try {
    console.log('[LOG] ëª¨ë“œ: latlon');
    console.log('[LOG] ê²©ì ë³€í™˜ ìš”ì²­ ì¢Œí‘œ:', { lat, lon });

    const response = await axios.get('https://apihub.kma.go.kr/api/typ01/cgi-bin/url/nph-dfs_xy_lonlat', {
      params: {
        lat,
        lon,
        authKey: WEATHER_API_KEY_KMA,
      },
    });

    const text = response.data;
    const match = text.match(/\s+(\d+\.\d+),\s+(\d+\.\d+),\s+(\d+),\s+(\d+)/);

    if (match) {
      const result = {
        lon: parseFloat(match[1]),
        lat: parseFloat(match[2]),
        x: parseInt(match[3]),
        y: parseInt(match[4]),
      };
      console.log('[LOG] ê²©ì ì •ë³´:', result);
      return result;
    } else {
      console.error('[ERROR] ê²©ì ì •ë³´ ì—†ìŒ.');
      return null;
    }
  } catch (error) {
    console.error('[ERROR] ê²©ì ë³€í™˜ ìš”ì²­ ì˜¤ë¥˜:', error.response || error.message);
    return null;
  }
};




-----------
index.js
// app/FarmInfo/index.js
import React, { useEffect, useState } from 'react';
import { View, Text, Button, ScrollView } from 'react-native';
import styles from '../Components/Css/FarmInfo/index.js';
import { fetchWeather } from '../Components/Css/FarmInfo/WeatherAPI';
import { getBaseDateTime } from '../Components/Utils/timeUtils';
import { getMidLandRegId } from '../Components/Utils/regionMapper';
import * as Location from 'expo-location';

const FARM_COORDS = {
  latitude: 36.953862288,
  longitude: 127.681782599,
};

export default function FarmInfo() {
  const [mode, setMode] = useState('farm');
  const [weatherData, setWeatherData] = useState(null);
  const [weeklyData, setWeeklyData] = useState(null);
  const [warningData, setWarningData] = useState('');
  const [loading, setLoading] = useState(false);

  const loadWeather = async () => {
    setLoading(true);
    let coords = FARM_COORDS;
    console.log('[ê³µí†µ] í˜„ì¬ ì„¤ì •ëœ ë†ì¥ ì¢Œí‘œ:', coords);

    if (mode === 'current') {
      try {
        const { status } = await Location.requestForegroundPermissionsAsync();
        if (status !== 'granted') {
          console.error('[ê³µí†µ] ìœ„ì¹˜ ê¶Œí•œ ê±°ë¶€ë¨');
          setLoading(false);
          return;
        }

        const position = await Location.getCurrentPositionAsync({});
        coords = {
          latitude: position.coords.latitude,
          longitude: position.coords.longitude,
        };
        console.log('[ê³µí†µ] í˜„ì¬ ìœ„ì¹˜ ì¢Œí‘œ:', coords);
      } catch (error) {
        console.error('[ê³µí†µ] í˜„ì¬ ìœ„ì¹˜ ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨:', error);
        setLoading(false);
        return;
      }
    }

    const now = new Date();
    const currentHour = now.getHours();
    const baseDate = new Date(now);

    if (currentHour < 6) {
      baseDate.setDate(baseDate.getDate() - 1);
    }

    const yyyy = baseDate.getFullYear();
    const mm = String(baseDate.getMonth() + 1).padStart(2, '0');
    const dd = String(baseDate.getDate()).padStart(2, '0');
    const dateStr = `${yyyy}${mm}${dd}`;
    const tmFc = currentHour < 6 || currentHour >= 18 ? `${dateStr}1800` : `${dateStr}0600`;

    const { base_date, base_time } = getBaseDateTime();
    console.log('[ê³µí†µ] ê¸°ì¤€ ë‚ ì§œ ë° ì‹œê°„:', base_date, base_time);

    const grid = await fetchWeather('latlon', {
      lat: coords.latitude,
      lon: coords.longitude,
    });
    console.log('[ê²©ìë³€í™˜] ê²°ê³¼:', grid);
    if (!grid || !grid.x || !grid.y) {
      setLoading(false);
      return;
    }

    console.log('[ì‹œê°„ëŒ€ë³„ ë‚ ì”¨] ìš”ì²­ ì¢Œí‘œ:', grid.x, grid.y);
    const forecast = await fetchWeather('ultraFcst', {
      nx: grid.x,
      ny: grid.y,
      base_date,
      base_time,
    });
    console.log('[ì‹œê°„ëŒ€ë³„ ë‚ ì”¨] ì‘ë‹µ:', forecast);

    const regId = getMidLandRegId(coords.latitude, coords.longitude);
    const midForecast = await fetchWeather('midLandFcst', { regId, tmFc });
    console.log('[ì£¼ê°„ ë‚ ì”¨] ìš”ì²­ íŒŒë¼ë¯¸í„°:', { regId, tmFc });
    console.log('[ì£¼ê°„ ë‚ ì”¨] ì‘ë‹µ:', midForecast);

    const warning = await fetchWeather('warning');
    console.log('[ê¸°ìƒ íŠ¹ë³´] ì‘ë‹µ:', warning);

    if (forecast) setWeatherData(forecast);

    // âœ… ì£¼ê°„ ë‚ ì”¨ íŒŒì‹± ë¡œì§ ê°œì„  (ì¤‘ìš”)
    const itemRaw = midForecast?.response?.body?.items?.item;
    const itemArray = itemRaw
      ? Array.isArray(itemRaw)
        ? itemRaw
        : [itemRaw]
      : [];

    const filteredItems = itemArray.filter(
      (item) => item.wfAm || item.wfPm
    );

    if (
      midForecast?.response?.header?.resultCode === '00' &&
      filteredItems.length > 0
    ) {
      setWeeklyData({
        response: { body: { items: { item: filteredItems } } },
      });
    } else {
      console.warn('[ì£¼ê°„ ë‚ ì”¨] ìœ íš¨í•˜ì§€ ì•Šì€ ì‘ë‹µ ë˜ëŠ” ë°ì´í„° ì—†ìŒ:', midForecast);
    }

    if (typeof warning === 'string') setWarningData(warning);
    setLoading(false);
  };

  useEffect(() => {
    loadWeather();
  }, [mode]);

  const getEmojiForPty = (value) => {
    switch (value) {
      case '0': return 'â˜€ ';
      case '1': return 'ğŸŒ§ ';
      case '2': return 'ğŸŒ¦ ';
      case '3': return 'â„ ';
      case '4': return 'ğŸŒ¨ ';
      default: return 'â˜ ';
    }
  };

  const getEmojiForSky = (value) => {
    switch (value) {
      case '1': return 'â˜€ ';
      case '3': return 'â›… ';
      case '4': return 'â˜ ';
      default: return 'â˜ ';
    }
  };

  const renderForecast = () => {
    const msg = weatherData?.response?.header?.resultMsg;
    const code = weatherData?.response?.header?.resultCode;
    if (msg !== 'NORMAL_SERVICE') return <Text style={styles.errorText}>ì—ëŸ¬: {msg} (ì½”ë“œ {code})</Text>;

    const items = weatherData?.response?.body?.items?.item || [];
    const categories = ['PTY', 'RN1', 'SKY', 'T1H', 'REH'];
    const grouped = {};

    for (const item of items) {
      if (!categories.includes(item.category)) continue;
      if (!grouped[item.fcstTime]) grouped[item.fcstTime] = {};
      grouped[item.fcstTime][item.category] = item.fcstValue;
    }

    console.log('[ì‹œê°„ëŒ€ë³„ ë‚ ì”¨] ê·¸ë£¹í™”ëœ ë°ì´í„°:', grouped);

    const now = new Date();
    const currentHour = now.getHours();
    const sortedTimes = Object.keys(grouped).sort((a, b) => {
      const aHour = parseInt(a);
      const bHour = parseInt(b);
      const offsetA = (aHour + 24 - currentHour) % 24;
      const offsetB = (bHour + 24 - currentHour) % 24;
      return offsetA - offsetB;
    });

    return (
      <ScrollView style={{ maxHeight: 600 }} nestedScrollEnabled={true}>
        {sortedTimes.map((time, idx) => {
          const data = grouped[time] || {};
          const pty = data['PTY'];
          const rn1 = data['RN1'];
          const sky = data['SKY'];
          const t1h = data.hasOwnProperty('T1H') ? ` ${data['T1H']} â„ƒ ` : ' - ';
          const reh = data.hasOwnProperty('REH') ? `${data['REH']}% ` : ' - ';
          const emoji = pty !== '0' ? getEmojiForPty(pty) : getEmojiForSky(sky);
          const rainInfo = rn1 ? (pty !== '0 ' && rn1 !== 'ê°•ìˆ˜ì—†ìŒ ' ? `${rn1}` : 'ê°•ìˆ˜ì—†ìŒ ') : 'ê°•ìˆ˜ì—†ìŒ ';
          const hour = `${String(time).padStart(4, '0').slice(0, 2)} ì‹œ`;

          return (
            <View key={idx} style={styles.row}>
              <Text style={styles.time}>{hour}</Text>
              <Text style={styles.value}>{emoji}</Text>
              <Text style={styles.value}>{rainInfo}</Text>
              <Text style={styles.value}>{t1h}</Text>
              <Text style={styles.value}>{reh}</Text>
            </View>
          );
        })}
      </ScrollView>
    );
  };

  const renderWeekly = () => {
    const items = weeklyData?.response?.body?.items?.item || [];
    console.log('[ì£¼ê°„ ë‚ ì”¨] ì›ì‹œ ë°ì´í„°:', items);
    if (items.length === 0) return <Text style={styles.noWarning}>ì£¼ê°„ ì˜ˆë³´ ë°ì´í„° ì—†ìŒ</Text>;

    const getEmoji = (text) => {
      if (text.includes('ë§‘')) return 'â˜€ ';
      if (text.includes('êµ¬ë¦„ë§')) return 'â›… ';
      if (text.includes('íë¦¼')) return 'â˜ ';
      if (text.includes('ë¹„')) return 'ğŸŒ§ ';
      if (text.includes('ëˆˆ')) return 'â„ ';
      return 'â“';
    };

    return items.map((item, idx) => (
      <View key={idx} style={styles.row}>
        <Text style={styles.time}>{item.fcstDate || `Day ${idx + 1}`}</Text>
        <Text style={styles.value}>{getEmoji(item.wfAm)} / {getEmoji(item.wfPm)}</Text>
        <Text style={styles.value}>{item.wfAm} / {item.wfPm}</Text>
      </View>
    ));
  };

  const renderWarning = () => {
    const lines = typeof warningData === 'string'
      ? warningData.split('\n').filter(line => line.startsWith('L'))
      : [];
    console.log('[ê¸°ìƒ íŠ¹ë³´] íŒŒì‹±ëœ íŠ¹ë³´ ë¼ì¸:', lines);
    if (lines.length === 0) return <Text style={styles.noWarning}>í˜„ì¬ ë°œíš¨ ì¤‘ì¸ íŠ¹ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.</Text>;
    return lines.map((line, idx) => <Text key={idx} style={styles.warningLine}>{line}</Text>);
  };

  return (
    <ScrollView style={styles.container} nestedScrollEnabled={true}>
      <View style={styles.tabContainer}>
        <Button title="ë‚´ ë†ì¥ ë‚ ì”¨" onPress={() => setMode('farm')} />
        <Button title="í˜„ ìœ„ì¹˜ ë‚ ì”¨" onPress={() => setMode('current')} />
      </View>

      <View style={styles.weatherBox}>
        <Text style={styles.sectionTitle}>[ì‹œê°„ëŒ€ë³„ ë‚ ì”¨]</Text>
        {loading ? (
          <Text style={styles.loading}>ë¡œë”©ì¤‘...</Text>
        ) : (
          renderForecast()
        )}
      </View>

      <View style={styles.weatherBox}>
        <Text style={styles.sectionTitle}>[ì£¼ê°„ ë‚ ì”¨]</Text>
        {loading ? (
          <Text style={styles.loading}>ë¡œë”©ì¤‘...</Text>
        ) : (
          renderWeekly()
        )}
      </View>

      <View style={styles.weatherBox}>
        <Text style={styles.sectionTitle}>[ê¸°ìƒ íŠ¹ë³´]</Text>
        {loading ? (
          <Text style={styles.loading}>ë¡œë”©ì¤‘...</Text>
        ) : (
          renderWarning()
        )}
      </View>
    </ScrollView>
  );
}



----------------
timeUtils.js

// app/Components/Utils/timeUtils.js
export const getBaseDateTime = () => {
  const now = new Date();

  // ê¸°ìƒì²­ APIëŠ” ë§¤ ì •ì‹œ ê¸°ì¤€, 40ë¶„ í›„ë¶€í„° ë°ì´í„°ë¥¼ ì œê³µí•¨
  // ì˜ˆ: 12:40 ì´í›„ â†’ base_timeì€ 12:00
  let baseDate = now;
  let baseTime = new Date(now.getTime() - 60 * 60 * 1000); // 1ì‹œê°„ ì „

  const y = baseDate.getFullYear();
  const m = String(baseDate.getMonth() + 1).padStart(2, '0');
  const d = String(baseDate.getDate()).padStart(2, '0');
  const h = String(baseTime.getHours()).padStart(2, '0');
  const min = baseTime.getMinutes();

  const base_date = `${y}${m}${d}`;
  const base_time = `${h}00`;

  return { base_date, base_time };
};



--------------------------
index.js

// app/FarmInfo/index.js
import React, { useEffect, useState } from 'react';
import { View, Text, Button, ScrollView } from 'react-native';
import styles from '../Components/Css/FarmInfo/index.js';
import { fetchWeather } from '../Components/Css/FarmInfo/WeatherAPI';
import { getBaseDateTime } from '../Components/Utils/timeUtils';
import { getMidLandRegId } from '../Components/Utils/regionMapper';
import * as Location from 'expo-location';

const FARM_COORDS = {
  latitude: 36.953862288,
  longitude: 127.681782599,
};

export default function FarmInfo() {
  const [mode, setMode] = useState('farm');
  const [weatherData, setWeatherData] = useState(null);
  const [weeklyData, setWeeklyData] = useState(null);
  const [warningData, setWarningData] = useState('');
  const [loading, setLoading] = useState(false);

  const loadWeather = async () => {
    setLoading(true);
    let coords = FARM_COORDS;
    console.log('[ê³µí†µ] í˜„ì¬ ì„¤ì •ëœ ë†ì¥ ì¢Œí‘œ:', coords);

    if (mode === 'current') {
      try {
        const { status } = await Location.requestForegroundPermissionsAsync();
        if (status !== 'granted') {
          console.error('[ê³µí†µ] ìœ„ì¹˜ ê¶Œí•œ ê±°ë¶€ë¨');
          setLoading(false);
          return;
        }

        const position = await Location.getCurrentPositionAsync({});
        coords = {
          latitude: position.coords.latitude,
          longitude: position.coords.longitude,
        };
        console.log('[ê³µí†µ] í˜„ì¬ ìœ„ì¹˜ ì¢Œí‘œ:', coords);
      } catch (error) {
        console.error('[ê³µí†µ] í˜„ì¬ ìœ„ì¹˜ ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨:', error);
        setLoading(false);
        return;
      }
    }

    const now = new Date();
    const currentHour = now.getHours();
    const baseDate = new Date(now);
    if (currentHour < 6) baseDate.setDate(baseDate.getDate() - 1);

    const yyyy = baseDate.getFullYear();
    const mm = String(baseDate.getMonth() + 1).padStart(2, '0');
    const dd = String(baseDate.getDate()).padStart(2, '0');
    const dateStr = `${yyyy}${mm}${dd}`;
    const tmFc = currentHour < 6 || currentHour >= 18 ? `${dateStr}1800` : `${dateStr}0600`;

    const { base_date, base_time } = getBaseDateTime();
    console.log('[ê³µí†µ] ê¸°ì¤€ ë‚ ì§œ ë° ì‹œê°„:', base_date, base_time);

    const grid = await fetchWeather('latlon', {
      lat: coords.latitude,
      lon: coords.longitude,
    });
    console.log('[ê²©ìë³€í™˜] ê²°ê³¼:', grid);
    if (!grid || !grid.x || !grid.y) {
      setLoading(false);
      return;
    }

    console.log('[ì‹œê°„ëŒ€ë³„ ë‚ ì”¨] ìš”ì²­ ì¢Œí‘œ:', grid.x, grid.y);
    const forecast = await fetchWeather('ultraFcst', {
      nx: grid.x,
      ny: grid.y,
      base_date,
      base_time,
    });
    console.log('[ì‹œê°„ëŒ€ë³„ ë‚ ì”¨] ì‘ë‹µ:', forecast);

    const regId = getMidLandRegId(coords.latitude, coords.longitude);
    const midForecast = await fetchWeather('midLandFcst', { regId, tmFc });
    console.log('[ì£¼ê°„ ë‚ ì”¨] ìš”ì²­ íŒŒë¼ë¯¸í„°:', { regId, tmFc });
    console.log('[ì£¼ê°„ ë‚ ì”¨] ì‘ë‹µ:', midForecast);

    const warning = await fetchWeather('warning');
    console.log('[ê¸°ìƒ íŠ¹ë³´] ì‘ë‹µ:', warning);

    if (forecast) setWeatherData(forecast);

    const itemRaw = midForecast?.response?.body?.items?.item;
    const itemArray = Array.isArray(itemRaw) ? itemRaw : itemRaw ? [itemRaw] : [];

    const hasValidForecast = (item) => {
      const keys = Object.keys(item || {});
      return keys.some((key) => /^wf[4-9](Am|Pm)?$/.test(key) || key === 'wf10');
    };

    const filteredItems = itemArray.filter((item) => hasValidForecast(item));
    console.log('[ì£¼ê°„ ë‚ ì”¨] ì‘ë‹µ ì›ë³¸ item:', itemArray);
    console.log('[ì£¼ê°„ ë‚ ì”¨] í•„í„°ë§ëœ item:', filteredItems);

    if (filteredItems.length > 0) {
      setWeeklyData(filteredItems[0]);
      console.log('[ì£¼ê°„ ë‚ ì”¨] ìµœì¢… íŒŒì‹±ëœ ë°ì´í„°:', filteredItems[0]);
    } else {
      console.warn('[ì£¼ê°„ ë‚ ì”¨] ìœ íš¨í•˜ì§€ ì•Šì€ ì‘ë‹µ ë˜ëŠ” ë°ì´í„° ì—†ìŒ:', midForecast);
      setWeeklyData(null);
    }

    if (typeof warning === 'string') setWarningData(warning);
    setLoading(false);
  };

  useEffect(() => {
    loadWeather();
  }, [mode]);

  const getEmojiForPty = (value) => {
    switch (value) {
      case '0': return 'â˜€ ';
      case '1': return 'ğŸŒ§ ';
      case '2': return 'ğŸŒ¦ ';
      case '3': return 'â„ ';
      case '4': return 'ğŸŒ¨ ';
      default: return 'â˜€ ';
    }
  };

  const getEmojiForSky = (value) => {
    switch (value) {
      case '1': return 'â˜€ ';
      case '3': return 'â›… ';
      case '4': return 'â˜ ';
      default: return 'â˜€ ';
    }
  };

  const renderForecast = () => {
    const msg = weatherData?.response?.header?.resultMsg;
    const code = weatherData?.response?.header?.resultCode;
    if (msg !== 'NORMAL_SERVICE') return <Text style={styles.errorText}>ì—ëŸ¬: {msg} (ì½”ë“œ {code})</Text>;

    const items = weatherData?.response?.body?.items?.item || [];
    const categories = ['PTY', 'RN1', 'SKY', 'T1H', 'REH'];
    const grouped = {};

    for (const item of items) {
      if (!categories.includes(item.category)) continue;
      if (!grouped[item.fcstTime]) grouped[item.fcstTime] = {};
      grouped[item.fcstTime][item.category] = item.fcstValue;
    }

    console.log('[ì‹œê°„ëŒ€ë³„ ë‚ ì”¨] ê·¸ë£¹í™”ëœ ë°ì´í„°:', grouped);

    const now = new Date();
    const currentHour = now.getHours();
    const sortedTimes = Object.keys(grouped).sort((a, b) => {
      const aHour = parseInt(a);
      const bHour = parseInt(b);
      const offsetA = (aHour + 24 - currentHour) % 24;
      const offsetB = (bHour + 24 - currentHour) % 24;
      return offsetA - offsetB;
    });

    return (
      <ScrollView style={{ maxHeight: 600 }} nestedScrollEnabled={true}>
        {sortedTimes.map((time, idx) => {
          const data = grouped[time] || {};
          const pty = data['PTY'];
          const rn1 = data['RN1'];
          const sky = data['SKY'];
          const t1h = data.hasOwnProperty('T1H') ? ` ${data['T1H']} â„ƒ ` : ' - ';
          const reh = data.hasOwnProperty('REH') ? `${data['REH']}% ` : ' - ';
          const emoji = pty !== '0' ? getEmojiForPty(pty) : getEmojiForSky(sky);
          const rainInfo = rn1 ? (pty !== '0 ' && rn1 !== 'ê°•ìˆ˜ì—†ìŒ ' ? `${rn1}` : 'ê°•ìˆ˜ì—†ìŒ ') : 'ê°•ìˆ˜ì—†ìŒ ';
          const hour = `${String(time).padStart(4, '0').slice(0, 2)} ì‹œ`;

          return (
            <View key={idx} style={styles.row}>
              <Text style={styles.time}>{hour}</Text>
              <Text style={styles.value}>{emoji}</Text>
              <Text style={styles.value}>{rainInfo}</Text>
              <Text style={styles.value}>{t1h}</Text>
              <Text style={styles.value}>{reh}</Text>
            </View>
          );
        })}
      </ScrollView>
    );
  };

  const renderWeekly = () => {
    try {
      if (!weeklyData) {
        return <Text style={styles.noWarning}>ì£¼ê°„ ë‚ ì”¨ ë°ì´í„° ì—†ìŒ</Text>;
      }

      const getEmoji = (text) => {
        if (!text) return 'â“';
        if (text.includes('ë§‘')) return 'â˜€ ';
        if (text.includes('êµ¬ë¦„ë§')) return 'â›… ';
        if (text.includes('íë¦¼')) return 'â˜ ';
        if (text.includes('ë¹„')) return 'ğŸŒ§ ';
        if (text.includes('ëˆˆ')) return 'â„ ';
        return 'â“';
      };

      const dayList = [
        { am: 'wf4Am', pm: 'wf4Pm' },
        { am: 'wf5Am', pm: 'wf5Pm' },
        { am: 'wf6Am', pm: 'wf6Pm' },
        { am: 'wf7Am', pm: 'wf7Pm' },
        { am: 'wf8', pm: null },
        { am: 'wf9', pm: null },
        { am: 'wf10', pm: null },
      ];

      const today = new Date();
      const weeklyDates = Array.from({ length: dayList.length }, (_, i) => {
        const d = new Date(today);
        d.setDate(d.getDate() + i + 3);
        return `${d.getMonth() + 1}/${d.getDate()}`;
      });

      return (
        <ScrollView style={{ maxHeight: 400 }} nestedScrollEnabled={true}>
          {dayList.map((field, idx) => {
            const amText = weeklyData[field.am];
            const pmText = field.pm ? weeklyData[field.pm] : null;
            const emoji = `${getEmoji(amText)}${pmText ? '/ ' + getEmoji(pmText) : ''}`;
            const desc = `${amText || ''}${pmText ? ' / ' + pmText : ''}`;
            return (
              <View key={idx} style={styles.row}>
                <Text style={styles.time}>{weeklyDates[idx]}</Text>
                <Text style={styles.value}>{emoji}</Text>
                <Text style={styles.value}>{desc}</Text>
              </View>
            );
          })}
        </ScrollView>
      );
    } catch (e) {
      console.warn('[ì£¼ê°„ ë‚ ì”¨] ë Œë” ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', e);
      return <Text style={styles.noWarning}>ì£¼ê°„ ë‚ ì”¨ ë°ì´í„° ì—†ìŒ</Text>;
    }
  };
  

  const renderWarning = () => {
    const lines = typeof warningData === 'string'
      ? warningData.split('\n').filter(line => line.startsWith('L'))
      : [];
    console.log('[ê¸°ìƒ íŠ¹ë³´] íŒŒì‹±ëœ íŠ¹ë³´ ë¼ì¸:', lines);
    if (lines.length === 0) return <Text style={styles.noWarning}>í˜„ì¬ ë°œíš¨ ì¤‘ì¸ íŠ¹ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.</Text>;
    return lines.map((line, idx) => <Text key={idx} style={styles.warningLine}>{line}</Text>);
  };

  return (
    <ScrollView style={styles.container} nestedScrollEnabled={true}>
      <View style={styles.tabContainer}>
        <Button title="ë‚´ ë†ì¥ ë‚ ì”¨" onPress={() => setMode('farm')} />
        <Button title="í˜„ ìœ„ì¹˜ ë‚ ì”¨" onPress={() => setMode('current')} />
      </View>

      <View style={styles.weatherBox}>
        <Text style={styles.sectionTitle}>[ì‹œê°„ëŒ€ë³„ ë‚ ì”¨]</Text>
        {loading ? <Text style={styles.loading}>ë¡œë”©ì¤‘...</Text> : renderForecast()}
      </View>

      <View style={styles.weatherBox}>
        <Text style={styles.sectionTitle}>[ì£¼ê°„ ë‚ ì”¨]</Text>
        {loading ? <Text style={styles.loading}>ë¡œë”©ì¤‘...</Text> : renderWeekly()}
      </View>

      <View style={styles.weatherBox}>
        <Text style={styles.sectionTitle}>[ê¸°ìƒ íŠ¹ë³´]</Text>
        {loading ? <Text style={styles.loading}>ë¡œë”©ì¤‘...</Text> : renderWarning()}
      </View>
    </ScrollView>
  );
}

==========================
import { XMLParser } from 'fast-xml-parser';
import * as XLSX from 'xlsx';
import { Asset } from 'expo-asset';
import * as FileSystem from 'expo-file-system';
import itemCodeData from '../Components/Utils/item_code_data.json';
import { MARKET_API_KEY } from '../Components/API/apikey';
import axios from 'axios';

// ì‹¤ì œ API URL ì„¤ì •
const BASE_URL = 'http://211.237.50.150:7080/openapi';
const API_BASE_URL = BASE_URL; // axiosìš© ì¶”ê°€

// XMLì„ JSONìœ¼ë¡œ ë³€í™˜í•˜ëŠ” ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
const parseXmlToJson = async (xmlString) => {
  try {
    const parser = new XMLParser();
    const result = parser.parse(xmlString);
    return result;
  } catch (error) {
    console.error('[ERROR] XML íŒŒì‹± ì˜¤ë¥˜:', error);
    throw error;
  }
};

// Grid ID ìƒìˆ˜ ì •ì˜
const GRID_IDS = {
  MARKET_CODE: 'Grid_20240625000000000661_1',    // ë„ë§¤ì‹œì¥ ì½”ë“œ
  GRADE_CODE: 'Grid_20240626000000000663_1',     // ë“±ê¸‰ ì½”ë“œ
  ORIGIN_CODE: 'Grid_20240626000000000667_1',    // ì‚°ì§€ ì½”ë“œ
  ITEM_CODE: 'Grid_20240626000000000668_1',      // í’ˆëª© ì½”ë“œ
  SETTLEMENT_PRICE: 'Grid_20240625000000000653_1', // ë„ë§¤ì‹œì¥ ì •ì‚°ê°€ê²© ì •ë³´
  REALTIME_PRICE: 'Grid_20240625000000000654_1'  // ë„ë§¤ì‹œì¥ ì‹¤ì‹œê°„ ê²½ë½ ì •ë³´
};

// ë””ë²„ê·¸ìš©: JSON ë°ì´í„° í™•ì¸
console.log('[DEBUG] ë¡œë“œëœ JSON ë°ì´í„° ìƒ˜í”Œ:', 
  Array.isArray(itemCodeData) ? itemCodeData.slice(0, 2) : 'ë°ì´í„° í˜•ì‹ ì˜¤ë¥˜');

// ì„ íƒëœ itemCode, varietyCode ê¸°ë°˜ìœ¼ë¡œ cmpcd ì°¾ëŠ” í•¨ìˆ˜ ìˆ˜ì •
const findCmpcd = (itemCode, varietyCode) => {
  const normalizedItemCode = String(itemCode).padStart(2, '0');
  const normalizedVarietyCode = String(varietyCode).padStart(2, '0');
  const matched = itemCodeData.find(item => 
    item.itemCode === normalizedItemCode &&
    item.varietyCode === normalizedVarietyCode
  );
  console.log('[DEBUG] findCmpcd ê²€ìƒ‰:', { normalizedItemCode, normalizedVarietyCode, matched });
  return matched?.cmpcd || null;
};

// ì¼ë³„ ì‹œì„¸ ì¡°íšŒ í•¨ìˆ˜
export const getDailyPrice = async ({ large, mid, small, whsalcd, saledate }) => {
  try {
    // cmpcd ìë™ ì¶”ì¶œ ì‹œë„
    const cmpcd = findCmpcd(mid, small); // mid = itemCode, small = varietyCode

    // 1. í•„ìˆ˜ íŒŒë¼ë¯¸í„° ëˆ„ë½ ê²€ì‚¬
    if (!cmpcd || !large || !mid || !small || !whsalcd || !saledate) {
      console.warn('[ê²½ê³ ] í•„ìˆ˜ íŒŒë¼ë¯¸í„° ëˆ„ë½:', { cmpcd, large, mid, small, whsalcd, saledate });
      throw new Error('í•„ìˆ˜ íŒŒë¼ë¯¸í„°ê°€ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤.');
    }

    // 2. ë¬¸ìì—´ ì•ˆì „ ì²˜ë¦¬
    const queryParams = {
      AUCNGDE: String(saledate).trim(),
      WHSALCD: String(whsalcd).trim(),
      LARGE: String(large).trim(),
      MID: String(mid).trim(),
      SMALL: String(small).trim(),
      CMPCD: String(cmpcd).trim()
    };

    // 3. ìš”ì²­ URL ìƒì„±
    const url = new URL(`${API_BASE_URL}/${MARKET_API_KEY}/xml/${GRID_IDS.SETTLEMENT_PRICE}/1/100`);
    Object.entries(queryParams).forEach(([key, val]) => url.searchParams.append(key, val));
    console.log('[DEBUG] ì‹œì„¸ ì¡°íšŒ URL:', url.toString());

    // 4. API í˜¸ì¶œ
    const response = await axios.get(url.toString());
    console.log('[DEBUG] ì‹œì„¸ ì¡°íšŒ ì‘ë‹µ ìƒíƒœ:', response.status);

    // 5. XML íŒŒì‹±
    const parsed = new XMLParser({ ignoreAttributes: false }).parse(response.data);
    console.log('[DEBUG] íŒŒì‹±ëœ ì „ì²´ êµ¬ì¡°:', JSON.stringify(parsed, null, 2));

    // 6. ì—ëŸ¬ ì‘ë‹µ ì²˜ë¦¬
    const result = parsed?.[GRID_IDS.SETTLEMENT_PRICE]?.result;
    if (!result || result.code !== 'INFO-000') {
      throw new Error(`API ì‘ë‹µì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤. (${result?.message || 'ì•Œ ìˆ˜ ì—†ìŒ'})`);
    }

    // 7. ì‹¤ì œ ì‹œì„¸ ë°ì´í„° ë°˜í™˜
    const rows = parsed[GRID_IDS.SETTLEMENT_PRICE]?.row || [];
    return Array.isArray(rows) ? rows : [rows];

  } catch (error) {
    console.error('[ERROR] ì‹œì„¸ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:', error);
    return null;
  }
};



const MarketPriceService = {
  getDailyPrice,
  // í’ˆì¢…ë³„ ì¼ì¼ ì‹œì„¸ ì¡°íšŒ
  async getVarietyPrice(cropCode, varietyCode) {
    try {
      const url = `${BASE_URL}/${MARKET_API_KEY}/xml/${GRID_IDS.GRADE_CODE}/1/100?prdlstCd=${cropCode}`;
      console.log('[DEBUG] ìš”ì²­ URL:', url);
      
      const response = await fetch(url);
      console.log('[DEBUG] ì‘ë‹µ ìƒíƒœ:', response.status);
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const xmlData = await response.text();
      console.log('[DEBUG] XML ì‘ë‹µ:', xmlData);
      
      const jsonData = await parseXmlToJson(xmlData);
      console.log('[DEBUG] íŒŒì‹±ëœ JSON:', JSON.stringify(jsonData, null, 2));
      
      if (!jsonData || !jsonData[GRID_IDS.GRADE_CODE]) {
        throw new Error('API ì‘ë‹µì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.');
      }
      
      const gridData = jsonData[GRID_IDS.GRADE_CODE];
      
      if (!gridData.row || !Array.isArray(gridData.row)) {
        throw new Error('API ì‘ë‹µì— ìœ íš¨í•œ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
      }
      
      return gridData.row;
    } catch (error) {
      console.error('í’ˆì¢…ë³„ ì‹œì„¸ ì¡°íšŒ ì˜¤ë¥˜:', error);
      throw error;
    }
  },

  // ì‹œì„¸ ë¹„êµ (ê³¼ê±° vs í˜„ì¬)
  async comparePrices(cropCode, startDate, endDate) {
    try {
      const url = `${BASE_URL}/${MARKET_API_KEY}/xml/${GRID_IDS.GRADE_CODE}/1/100?startDate=${startDate}&endDate=${endDate}&prdlstCd=${cropCode}`;
      console.log('[DEBUG] ìš”ì²­ URL:', url);
      
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.text();
      return data;
    } catch (error) {
      console.error('ì‹œì„¸ ë¹„êµ ì¡°íšŒ ì˜¤ë¥˜:', error);
      throw error;
    }
  },

  // ì§€ì—­ë³„ ì‹œì„¸ ì¡°íšŒ
  async getRegionalPrices({ saledate, whsalcd, large, mid, small, cmpcd }) {
    // í•„ìˆ˜ íŒŒë¼ë¯¸í„° ì²´í¬
    if (!saledate || !whsalcd) {
      console.error('í•„ìˆ˜ íŒŒë¼ë¯¸í„° ëˆ„ë½:', { saledate, whsalcd });
      return null;
    }

    let url = `${BASE_URL}/${MARKET_API_KEY}/xml/Grid_0000001/1/100?SALEDATE=${saledate}&WHSALCD=${whsalcd}`;
    
    // ì„ íƒ íŒŒë¼ë¯¸í„° ì¶”ê°€
    if (large) url += `&LARGE=${large}`;
    if (mid) url += `&MID=${mid}`;
    if (small) url += `&SMALL=${small}`;
    if (cmpcd) url += `&CMPCD=${cmpcd}`;

    console.log('ì „êµ­ ì‹œì„¸ API ìš”ì²­ URL:', url);

    try {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const xmlData = await response.text();
      const jsonData = await parseXmlToJson(xmlData);
      
      if (!jsonData || !jsonData[GRID_IDS.SETTLEMENT_PRICE]) {
        throw new Error('API ì‘ë‹µì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.');
      }
      
      const gridData = jsonData[GRID_IDS.SETTLEMENT_PRICE];
      
      if (!gridData.row || !Array.isArray(gridData.row)) {
        throw new Error('API ì‘ë‹µì— ìœ íš¨í•œ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
      }
      
      return gridData.row.map(item => ({
        AUCNGDE: item.AUCNGDE,
        MRKTNM: item.MARKETNAME || item.MRKTNM,
        ITEM_NAME: item.ITEMNAME || item.ITEM_NAME,
        AVGPRI: item.AVGP || item.AVGPRI,
        MAXPRC: item.MAXP || item.MAXPRC,
        MINPRC: item.MINP || item.MINPRC,
        AUCTQY: item.VOLUME || item.AUCTQY
      }));
    } catch (error) {
      console.error('ì „êµ­ ì‹œì„¸ ì¡°íšŒ ì‹¤íŒ¨:', error);
      return null;
    }
  },

  // ë„ë§¤ì‹œì¥ ì½”ë“œ ì¡°íšŒ
  async getMarketCodes() {
    try {
      const url = `${BASE_URL}/${MARKET_API_KEY}/xml/${GRID_IDS.MARKET_CODE}/1/100`;
      console.log('[DEBUG] ìš”ì²­ URL:', url);
      
      const response = await fetch(url);
      console.log('[DEBUG] ì‘ë‹µ ìƒíƒœ:', response.status);
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const xmlData = await response.text();
      console.log('[DEBUG] XML ì‘ë‹µ:', xmlData);
      
      const jsonData = await parseXmlToJson(xmlData);
      console.log('[DEBUG] íŒŒì‹±ëœ JSON:', JSON.stringify(jsonData, null, 2));
      
      if (!jsonData || !jsonData[GRID_IDS.MARKET_CODE]) {
        throw new Error('API ì‘ë‹µì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.');
      }
      
      const gridData = jsonData[GRID_IDS.MARKET_CODE];
      
      if (!gridData.row || !Array.isArray(gridData.row)) {
        throw new Error('API ì‘ë‹µì— ìœ íš¨í•œ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
      }
      
      return gridData.row;
    } catch (error) {
      console.error('ë„ë§¤ì‹œì¥ ì½”ë“œ ì¡°íšŒ ì˜¤ë¥˜:', error);
      throw error;
    }
  },

  // í’ˆëª© ì½”ë“œ ì¡°íšŒ (JSON ë°ì´í„° ì‚¬ìš©)
  async getItemCodes(searchKeyword = '') {
    try {
      console.log('[DEBUG] í’ˆëª© ì½”ë“œ ì¡°íšŒ ì‹œì‘');
      console.log('[DEBUG] ì‚¬ìš©ì ì„ íƒ í’ˆëª©:', searchKeyword);
      console.log('[DEBUG] ì „ì²´ ë°ì´í„° ê°œìˆ˜:', itemCodeData.length);
      
      // ë°ì´í„° êµ¬ì¡° ë¶„ì„
      const categories = new Set();
      itemCodeData.forEach(item => {
        categories.add(`${item.categoryCode}:${item.categoryName}`);
      });
      console.log('[DEBUG] ì „ì²´ ì¹´í…Œê³ ë¦¬ ëª©ë¡:', Array.from(categories));
      
      // ê³¼ì¼ë¥˜ì™€ ì±„ì†Œë¥˜ ì¹´í…Œê³ ë¦¬ ì •ì˜
      const fruitCategories = ['6:ê³¼ì‹¤ë¥˜', '8:ê³¼ì¼ê³¼ì±„ë¥˜'];
      const vegetableCategories = [
        '9:ê³¼ì±„ë¥˜',
        '10:ì—½ê²½ì±„ë¥˜',
        '11:ê·¼ì±„ë¥˜',
        '12:ì¡°ë¯¸ì±„ì†Œë¥˜',
        '13:ì–‘ì±„ë¥˜',
        '14:ì‚°ì±„ë¥˜'
      ];
      
      console.log('[DEBUG] ì‚¬ìš©í•  ì¹´í…Œê³ ë¦¬:', {
        ê³¼ì¼: fruitCategories,
        ì±„ì†Œ: vegetableCategories
      });

      // ê³¼ì¼ë¥˜ì™€ ì±„ì†Œë¥˜ë¡œ ë¶„ë¥˜
      const categorizedItems = {
        fruits: itemCodeData.filter(item => 
          fruitCategories.includes(`${item.categoryCode}:${item.categoryName}`)
        ),
        vegetables: itemCodeData.filter(item => 
          vegetableCategories.includes(`${item.categoryCode}:${item.categoryName}`)
        )
      };
      
      // ê²€ìƒ‰ì–´ê°€ ì—†ëŠ” ê²½ìš° ì „ì²´ ë°ì´í„° ë°˜í™˜
      if (!searchKeyword || typeof searchKeyword !== 'string') {
        return categorizedItems;
        }

      // ê²€ìƒ‰ì–´ê°€ ìˆëŠ” ê²½ìš° í•„í„°ë§
          const keyword = searchKeyword.toLowerCase();
      const filteredData = {
        fruits: categorizedItems.fruits.filter(item => 
          (item.itemName || '').toLowerCase().includes(keyword) ||
          (item.varietyName || '').toLowerCase().includes(keyword)
        ),
        vegetables: categorizedItems.vegetables.filter(item => 
          (item.itemName || '').toLowerCase().includes(keyword) ||
          (item.varietyName || '').toLowerCase().includes(keyword)
        )
      };
      
      console.log('[DEBUG] ê²€ìƒ‰ì–´:', keyword);
      console.log('[DEBUG] ê²€ìƒ‰ ê²°ê³¼:', {
        fruits: filteredData.fruits.map(item => ({
          categoryName: item.categoryName,
          itemName: item.itemName,
          varietyName: item.varietyName
        })),
        vegetables: filteredData.vegetables.map(item => ({
          categoryName: item.categoryName,
          itemName: item.itemName,
          varietyName: item.varietyName
        }))
      });

      return filteredData;
    } catch (error) {
      console.error('[ERROR] í’ˆëª© ì½”ë“œ ì¡°íšŒ ì˜¤ë¥˜:', error);
      throw error;
    }
  },

  // ë“±ê¸‰ ì½”ë“œ ì¡°íšŒ
  async getGradeCodes() {
    try {
      const url = `${BASE_URL}/${MARKET_API_KEY}/xml/${GRID_IDS.GRADE_CODE}/1/100`;
      console.log('[DEBUG] ìš”ì²­ URL:', url);
      
      const response = await fetch(url);
      console.log('[DEBUG] ì‘ë‹µ ìƒíƒœ:', response.status);
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const xmlData = await response.text();
      console.log('[DEBUG] XML ì‘ë‹µ:', xmlData);
      
      const jsonData = await parseXmlToJson(xmlData);
      console.log('[DEBUG] íŒŒì‹±ëœ JSON:', JSON.stringify(jsonData, null, 2));
      
      if (!jsonData || !jsonData[GRID_IDS.GRADE_CODE]) {
        throw new Error('API ì‘ë‹µì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.');
      }
      
      const gridData = jsonData[GRID_IDS.GRADE_CODE];
      
      if (!gridData.row || !Array.isArray(gridData.row)) {
        throw new Error('API ì‘ë‹µì— ìœ íš¨í•œ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
      }
      
      return gridData.row;
    } catch (error) {
      console.error('ë“±ê¸‰ ì½”ë“œ ì¡°íšŒ ì˜¤ë¥˜:', error);
      throw error;
    }
  },

  // ì‚°ì§€ ì½”ë“œ ì¡°íšŒ
  async getOriginCodes() {
    try {
      const url = `${BASE_URL}/${MARKET_API_KEY}/xml/${GRID_IDS.ORIGIN_CODE}/1/100`;
      console.log('[DEBUG] ìš”ì²­ URL:', url);
      
      const response = await fetch(url);
      console.log('[DEBUG] ì‘ë‹µ ìƒíƒœ:', response.status);
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const xmlData = await response.text();
      console.log('[DEBUG] XML ì‘ë‹µ:', xmlData);
      
      const jsonData = await parseXmlToJson(xmlData);
      console.log('[DEBUG] íŒŒì‹±ëœ JSON:', JSON.stringify(jsonData, null, 2));
      
      if (!jsonData || !jsonData[GRID_IDS.ORIGIN_CODE]) {
        throw new Error('API ì‘ë‹µì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.');
      }
      
      const gridData = jsonData[GRID_IDS.ORIGIN_CODE];
      
      if (!gridData.row || !Array.isArray(gridData.row)) {
        throw new Error('API ì‘ë‹µì— ìœ íš¨í•œ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
      }
      
      return gridData.row;
    } catch (error) {
      console.error('ì‚°ì§€ ì½”ë“œ ì¡°íšŒ ì˜¤ë¥˜:', error);
      throw error;
    }
  },

  // ë„ë§¤ì‹œì¥ ì •ì‚° ê°€ê²© ì¡°íšŒ
  async getSettlementPrices(marketCode, itemCode, date) {
    try {
      const url = `${BASE_URL}/${MARKET_API_KEY}/xml/${GRID_IDS.SETTLEMENT_PRICE}/1/100?AUCNGDE=${date}`;
      console.log('[DEBUG] ìš”ì²­ URL:', url);
      
      const response = await fetch(url);
      console.log('[DEBUG] ì‘ë‹µ ìƒíƒœ:', response.status);
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const xmlData = await response.text();
      console.log('[DEBUG] XML ì‘ë‹µ:', xmlData);
      
      const jsonData = await parseXmlToJson(xmlData);
      console.log('[DEBUG] íŒŒì‹±ëœ JSON:', JSON.stringify(jsonData, null, 2));
      
      if (!jsonData || !jsonData[GRID_IDS.SETTLEMENT_PRICE]) {
        throw new Error('API ì‘ë‹µì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.');
      }
      
      const gridData = jsonData[GRID_IDS.SETTLEMENT_PRICE];
      
      if (!gridData.row || !Array.isArray(gridData.row)) {
        throw new Error('API ì‘ë‹µì— ìœ íš¨í•œ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
      }
      
      // í‰ê· ê°€, ìµœê³ ê°€, ìµœì €ê°€, ê±°ë˜ëŸ‰ ê³„ì‚°
      const prices = gridData.row.map(item => ({
        marketName: item.MARKETNAME,
        itemName: item.ITEMNAME,
        avgPrice: parseInt(item.AVGP),
        maxPrice: parseInt(item.MAXP),
        minPrice: parseInt(item.MINP),
        volume: parseInt(item.VOLUME)
      }));
      
      return prices;
    } catch (error) {
      console.error('ë„ë§¤ì‹œì¥ ì •ì‚° ê°€ê²© ì¡°íšŒ ì˜¤ë¥˜:', error);
      throw error;
    }
  },

  // ë„ë§¤ì‹œì¥ ì‹¤ì‹œê°„ ê²½ë½ ì •ë³´ ì¡°íšŒ
  async getRealTimePrices(marketCode, itemCode, date) {
    try {
      const url = `${BASE_URL}/${MARKET_API_KEY}/xml/${GRID_IDS.REALTIME_PRICE}/1/100?AUCNGDE=${date}`;
      console.log('[DEBUG] ìš”ì²­ URL:', url);
      
      const response = await fetch(url);
      console.log('[DEBUG] ì‘ë‹µ ìƒíƒœ:', response.status);
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const xmlData = await response.text();
      console.log('[DEBUG] XML ì‘ë‹µ:', xmlData);
      
      const jsonData = await parseXmlToJson(xmlData);
      console.log('[DEBUG] íŒŒì‹±ëœ JSON:', JSON.stringify(jsonData, null, 2));
      
      if (!jsonData || !jsonData[GRID_IDS.REALTIME_PRICE]) {
        throw new Error('API ì‘ë‹µì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.');
      }
      
      const gridData = jsonData[GRID_IDS.REALTIME_PRICE];
      
      if (!gridData.row || !Array.isArray(gridData.row)) {
        throw new Error('API ì‘ë‹µì— ìœ íš¨í•œ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
      }
      
      // ì‹œê°„ëŒ€ë³„ ë‚™ì°°ê°€ ì •ë³´ ì •ë¦¬
      const prices = gridData.row.map(item => ({
        marketName: item.MARKETNAME,
        itemName: item.ITEMNAME,
        time: item.TIME,
        price: parseInt(item.PRICE),
        grade: item.GRADE
      }));
      
      return prices;
    } catch (error) {
      console.error('ë„ë§¤ì‹œì¥ ì‹¤ì‹œê°„ ê²½ë½ ì •ë³´ ì¡°íšŒ ì˜¤ë¥˜:', error);
      throw error;
    }
  }
};

export default MarketPriceService;

apiì‘ë‹µì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŒ, ë‚ ì§œì˜ ì‹œì„¸ë¥¼ ë°›ì•„ì˜¬ ìˆ˜ ì—†ìŒ, item_code_data.jsonì— cmpcdíŒŒì¼ ì¶”ê°€í•¨






